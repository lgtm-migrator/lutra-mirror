#+INCLUDE: "./inc/header.org"

#+HTML:   <h1 id="top" class="title">Incrementally building a template library</h1>
#+HTML:   <img id="logo" alt="pOTTR" src="http://www.ottr.xyz/logo/pOTTR.png"/>
#+TITLE: pOTTR: Incrementally building a template library

 *A top-down modelling approach for building template libraries.*

 - Authors :: Daniel Lupp
 - Issues :: https://gitlab.com/ottr/language/pOTTR/issues

#+INCLUDE: "./inc/intro.org"

In this chapter will incrementally build a set of templates that model
the domain of mobile phone with the goal of representing the design of
the phone, i.e., which parts different models of phone consist of, and
the specific parts a specific phone (individual) consists of.

The reader should know the [[./01-basics.html][basics of OTTR]].

** Prefixes
   :PROPERTIES:
   :CUSTOM_ID: prefixes
   :END:

   The following prefixes are used throughout the document, and may be
   used in the text input areas of the interactive examples without
   declaration.

#+NAME: turtle-prefixes
#+BEGIN_SRC ttl
@prefix rdf: 	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
@prefix rdfs: 	<http://www.w3.org/2000/01/rdf-schema#> . 
@prefix owl: 	<http://www.w3.org/2002/07/owl#> . 
@prefix xsd: 	<http://www.w3.org/2001/XMLSchema#> . 
@prefix foaf: 	<http://xmlns.com/foaf/0.1/> . 
@prefix dbp: 	<http://dbpedia.org/ontology/> . 
@prefix ex: 	<http://example.com/ns#> . 
@prefix ottr: 	<http://ns.ottr.xyz/0.4/> . 
@prefix ax: 	<http://tpl.ottr.xyz/owl/axiom/0.1/> . 
@prefix rstr: 	<http://tpl.ottr.xyz/owl/restriction/0.1/> .
#+END_SRC


* Defining core patterns
** Exercise: Creating a signature
    
    Based on the following instances, write a suitable signature for
    the template ~ex:Phone~. Ignore for now that it is a base
    template, in the following exercises we will define it in more
    detail.

#+begin_weblutra
#+begin_input
#+ATTR_HTML: :textarea t
#+NAME: inst-phone-test1
#+BEGIN_SRC ttl
ex:Phone(ex:Nokia3310, (ex:Screen, ex:HardCase, ex:CPU), "indestructible"^^xsd:string).
ex:Phone(ex:SamsungS9, (ex:CurvedScreen, ex:FastCPU), none).
ex:Phone(ex:iPhone8, (ex:RetinaScreen, ex:OtherFastCPU, ex:FPReader), "iphone"^^xsd:string).
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
 ex:Phone[<fill in>] :: BASE.
#+END_SRC
#+end_library
#+end_weblutra


** Exercise: Extending the signature to a template
    
    Use the templates below as well as existing OWL templates to
    create the ~ex:Phone~ template. Use ~ex:ConsistsOf~ as a black box
    (this template will be defined in the next exercise).

#+begin_weblutra

#+begin_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-phone-test1>>
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
# ?name: the name of a particular class of phone
# ?components: the list of components the phone consists of
# ?label: an optional label
# Pattern description: ?name is a subclass of ex:Phone and consists of
#   all components in ?components. It has an optional label ?label.

ex:Phone[owl:Class ?name, NEList<owl:Class> ?components, ? xsd:string ?label] :: {
  # <fill in>
} .
 

# ?device: the name of the device
# ?components: the components the device consists of

ex:ConsistsOf[owl:Class ?device, NEList<owl:Class> ?components] :: BASE.

#+END_SRC
#+end_library
#+end_weblutra

*** Solution                                                       :noexport:

#+NAME: tpl-phone
#+BEGIN_SRC ttl
ex:Phone[owl:Class ?name, NEList<owl:Class> ?components, ? xsd:string ?label] :: {
  ax:SubClassOf(?name, ex:Phone),
  ottr:Triple(?name, rdfs:label, ?label),
  ex:ConsistsOf(?name, ?components)
}.
#+END_SRC

* Refining incrementally

** Exercise: Add ConsistsOf
 
    Use the ~ex:HasComponents~ and ~ex:OnlyComponents~ templates below
    to define the ~ex:ConsistsOf~ template. We will define
    ~ex:HasComponents~ and ~ex:OnlyComponents~ in the next exercise.

#+begin_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="fetchMissing" value="true"/>
#+begin_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-phone-test1>>
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
# ?device: the name of the class of device
# ?components: the list of components ?device consists of
# Pattern description: ?device consists of precisely the components in
#   ?components: it has one component from each class in ?components,
#   and any component ?device has must be from ?components

ex:ConsistsOf[owl:Class ?device, NEList<owl:Class> ?components] :: {
  # <fill in>
}.

# indicates that ?item has a component from each of the classes in ?components
ex:HasComponents[owl:Class ?item, NEList<owl:Class> ?components] :: BASE.

# indicates that ?item only has components from the classes in ?components
ex:OnlyComponents[owl:Class ?item, NEList<owl:Class> ?components] :: BASE.


### Previously defined:

<<tpl-phone>>
#+END_SRC
#+end_library
#+end_weblutra

*** Solution                                                       :noexport:

#+NAME: tpl-consistsof
#+BEGIN_SRC ttl
ex:ConsistsOf[owl:Class ?item, NEList<owl:Class> ?components] :: {
  ex:HasComponents(?item, ?components),
  ex:OnlyComponents(?item, ?components)
}.
#+END_SRC

** Exercise: Add HasComponents and OnlyComponents

    Use ~ex:HasComponent~ below as well as existing OWL and RDFS
    templates to define ~ex:HasComponents~ and
    ~ex:OnlyComponents~. (Hint: look at [[http://tpl.ottr.xyz/owl/restriction/0.1/ObjectUnionOf.ttl][rstr:ObjectUnionOf]] and
    [[http://tpl.ottr.xyz/owl/axiom/0.1/SubObjectAllValuesFrom.ttl][ax:SubObjectAllValuesFrom]]).


#+NAME: tpl-hascomponent
#+BEGIN_SRC ttl :exports none
ex:HasComponent[owl:Class ?item, owl:Class ?component] :: {
  ax:SubObjectSomeValuesFrom(?item, ex:hasComponent, ?component)
}.
#+END_SRC


#+begin_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="fetchMissing" value="true"/>
#+begin_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-phone-test1>>
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
# ?item: the name of a class of items
# ?components: a list of component classes
# Pattern description: ?item has a component from each of the classes in ?components

ex:HasComponents[owl:Class ?item, NEList<owl:Class> ?components] :: {
  # <fill in>
}.


# ?item: the name of a class of items
# ?components: a list of component classes
# Pattern description: any component ?item is related to via
#   ex:hasComponent must come from the union of classes in ?components

ex:OnlyComponents[owl:Class ?item, NEList<owl:Class> ?components] :: {
  # <fill in>
}.

<<tpl-hascomponent>>

### Previously defined:

<<tpl-phone>>

<<tpl-consistsof>>

#+END_SRC
#+end_library
#+end_weblutra

*** Solution                                                       :noexport:

#+NAME: tpl-hascomponents
#+BEGIN_SRC ttl
ex:HasComponents[owl:Class ?item, NEList<owl:Class> ?components] :: {
  cross | ex:HasComponent(?item, ++?components)
}.
#+END_SRC

#+NAME: tpl-onlycomponents
#+BEGIN_SRC ttl
ex:OnlyComponents[owl:Class ?item, NEList<owl:Class> ?components] :: {
  rstr:ObjectUnionOf(_:b, ?components),
  ax:SubObjectAllValuesFrom(?item, ex:hasComponent, _:b)
}.
#+END_SRC

* Instantiation

** Exercise: Add PhoneInstance
 
    Now we are going to create a template for populating phone
    classes: ~ex:PhoneInstance~. Define the template
    ~ex:PhoneInstance~ below.

#+begin_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="fetchMissing" value="true"/>
#+begin_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-phone-test1>>
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
# ?phoneInstance: the identifer for a specific phone
# ?phone: a class of phones
# ?components: a list of specific components
# Pattern description: ?phoneInstance is of type ?phone and has the
#   components (i.e., is related to via ex:hasComponent) given in ?components.

ex:PhoneInstance[owl:NamedIndividual ?phoneInstance, owl:Class ?phone, NEList<owl:NamedIndividual> ?components] :: {
    # <fill in>
}.


### Previously defined:

<<tpl-phone>>
<<tpl-consistsof>>
<<tpl-hascomponent>>
<<tpl-hascomponents>>
<<tpl-onlycomponents>>

#+END_SRC
#+end_library
#+end_weblutra

*** Solution                                                       :noexport:

#+NAME: tpl-phoneinstance
#+BEGIN_SRC ttl
ex:PhoneInstance[owl:NamedIndividual ?phoneInstance, owl:Class ?phone, NEList<owl:NamedIndividual> ?components] :: {
   ottr:Triple(?phoneInstance, rdf:type, ?phone),
   cross | ottr:Triple(?phoneInstance, ex:hasComponent, ++?components)
}.
#+END_SRC

** Exercise: Instantiation

    Create one or more new phone classes and populate them with
    specific phones.

#+begin_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="fetchMissing" value="true"/>
#+begin_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-phone-test1>>
#+END_SRC
#+end_input

#+begin_library
#+ATTR_HTML: :textarea t
#+NAME: full-library
#+BEGIN_SRC ttl :noweb yes

### Previously defined:

<<tpl-phoneinstance>>

<<tpl-phone>>
<<tpl-consistsof>>
<<tpl-hascomponent>>
<<tpl-hascomponents>>
<<tpl-onlycomponents>>
#+END_SRC
#+end_library
#+end_weblutra

#+BEGIN_SRC ttl :noweb yes :mkdirp yes :tangle files/02-modelling/1/ins/phoneinst.stottr
<<turtle-prefixes>>

<<inst-phone-test1>>
#+END_SRC


#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/02-modelling/1/tpl/all.stottr
<<turtle-prefixes>>

<<full-library>>
#+END_SRC

* Appendix
#+INCLUDE: "./inc/appendix.org"




