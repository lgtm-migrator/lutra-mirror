#+INCLUDE: "./inc/header.org"

#+HTML:   <h1 id="top" class="title">The Basics of Reasonable Ontology Templates</h1>
#+HTML:   <img id="logo" alt="pOTTR" src="http://www.ottr.xyz/logo/pOTTR.png"/>
#+TITLE: pOTTR: The Basics of Reasonable Ontology Templates

 *Learn the basics of OTTR*

 - Authors :: Leif Harald Karlsen, Martin G. Skj√¶veland
 - Issues :: https://gitlab.com/ottr/language/pOTTR/issues

#+INCLUDE: "./inc/intro.org"

This primer is a lightweight introduction to the basics concepts of
OTTR templates. The fundamentals of OTTR are formally defined in mOTTR
[[[mottr]]]. The syntax used in this document is stOTTR [[[stottr]]].

** Prefixes
   :PROPERTIES:
   :CUSTOM_ID: prefixes
   :END:

   The following prefixes are used throughout the document, and may be
   used in the text input areas of the interactive examples without
   declaration.

#+NAME: turtle-prefixes
#+BEGIN_SRC ttl
@prefix rdf: 	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
@prefix rdfs: 	<http://www.w3.org/2000/01/rdf-schema#> . 
@prefix owl: 	<http://www.w3.org/2002/07/owl#> . 
@prefix xsd: 	<http://www.w3.org/2001/XMLSchema#> . 
@prefix foaf: 	<http://xmlns.com/foaf/0.1/> . 
@prefix dbp: 	<http://dbpedia.org/ontology/> . 
@prefix ex: 	<http://example.com/ns#> . 
@prefix ottr: 	<http://ns.ottr.xyz/0.4/> . 
@prefix ax: 	<http://tpl.ottr.xyz/owl/axiom/0.1/> . 
@prefix rstr: 	<http://tpl.ottr.xyz/owl/restriction/0.1/> .
#+END_SRC

** Lutra setup                                                     :noexport:

#+BEGIN_SRC sh :exports results
if [ ! -f .temp/lutra.jar ];
then
  mkdir -p .temp
  wget https://gitlab.com/ottr/lutra/lutra/-/jobs/artifacts/master/raw/lutra.jar?job=release -O .temp/lutra.jar
fi
#+END_SRC

#+RESULTS:

#+NAME: lutra
#+BEGIN_SRC sh :results output :exports results :var args=""
java -jar .temp/lutra.jar $args 2>&1
#+END_SRC

#+RESULTS: lutra
: 
: [ERROR] Must provide one or more input files. For help on usage, use the --help option.


* Templates and Instances

The core concepts in OTTR are /templates/ and /instances/ of
templates.

Here are two instances of the template ~ex:Person~, which is listed
below. The first instance specifies the 3 /arguments/: ~"Ann"~, ~"Strong"~ and
~<mailto:ann.strong@gmail.com>~:

#+NAME: inst-person
#+BEGIN_SRC ttl
ex:Person("Ann", "Strong", <mailto:ann.strong@gmail.com>) .
ex:Person("Bob", "Brite", <mailto:bob.brite@gmail.com>) .
#+END_SRC

A template consists of a /signature/ and a /pattern/.  The signature
of template specifies its /identifier/ and its parameters.  The
pattern contains (other) instances and may use the template's
parameters as arguments.

This is the ~ex:Person~ template. It specifies 3 parameters,
~?firstName~, ~?lastName~ and ~?email~, and contains 3 instances of
the ~ottr:Triple~ template in its pattern. The arguments of an
instance must match the parameters of its template.

#+NAME: tpl-person
#+BEGIN_SRC ttl
ex:Person[ ?firstName, ?lastName, ?email ] :: {
  ottr:Triple (_:person, rdf:type, foaf:Person ),
  ottr:Triple (_:person, foaf:firstName, ?firstName ),
  ottr:Triple (_:person, foaf:lastName, ?lastName ),
  ottr:Triple (_:person, foaf:mbox, ?email )
} .
#+END_SRC

   An instance represents a replica of the template pattern where the
   template's parameters have been replaced by the arguments of the
   instance. An instance can be /expanded/ by recursively replacing
   instances with the pattern they represent.


#+COMMENT: Here we tangle to files for showing the expansion 

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/1/tpl/Person.stottr
<<turtle-prefixes>>
<<tpl-person>>
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/1/ins/Person1.stottr
<<turtle-prefixes>>
<<inst-person>>
#+END_SRC

This is the expansion of the example ~ex:Person~ instance when we
expand to stOTTR [[[stottr]]] syntax:

#+CALL: lutra(args="-l files/01-basics/1/tpl/Person.stottr -L stottr -O stottr -I stottr files/01-basics/1/ins/Person1.stottr")

#+RESULTS:
: @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
: @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
: @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
: @prefix owl: <http://www.w3.org/2002/07/owl#> .
: @prefix ottr: <http://ns.ottr.xyz/0.4/> .
: 
: 

This is the expansion of the instance when we expand to wOTTR [[[wottr]]]
syntax, the RDF serialisation format of OTTR:

#+CALL: lutra(args="-l files/01-basics/1/tpl/Person.stottr -L stottr -O wottr -I stottr files/01-basics/1/ins/Person1.stottr")

The expansion is done by our reference implementation Lutra. Lutra has
special support for instances of the template ~ottr:Triple~ and treats
them as regular RDF triples.

** Exercise: Getting familiar with the interactive exercise form

    This primer contains interactive exercises where you can test and
    run your solution directly. Usually each exercise contains one
    input box for template instances, and one box for templates. When
    clicking the "Run" button at the bottom, the instances in the
    instance box are expanded using the templates in the template box,
    or using templates fetched by their IRI or the templates found in
    the standard library at http://tpl.ottr.xyz, if these options set
    to true.  

    One can also change the what should happen when one clicks "Run"
    by changing "Action" on the same line as "Run", and change the
    output format to, e.g., stOTTR.


#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<inst-person>>
#+END_SRC
#+END_input
#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<tpl-person>>
#+END_SRC
#+END_library
#+end_weblutra


    In this exercise we will get familiar with this setup, so do the
    following:

    - Click the "Run" button to expand the instances
    - Add a few more instances of the ~ex:Person~ template in the
      instance-box and click "Run" to expand them
    - Do some changes in the pattern of the ~ex:Person~ template,
      e.g., change ~foaf:lastName~ to ~foaf:surname~, click "Run" and
      see the effects of the expansion.
    - Change the output format to stOTTR and click "Run"

** Exercise: Create a new template

    Create a template ~ex:Organization~ such that the instance below
    expands to the following RDF graph:

    Note that ~#~ can be used to add comments.

#+CALL: lutra(args="-l files/01-basics/15/tpl/Organisation.stottr -L stottr -O wottr -I stottr files/01-basics/15/ins/Organisation.stottr")

#+RESULTS:
: @prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
: @prefix foaf:  <http://xmlns.com/foaf/0.1/> .
: 
: [ a              foaf:Organization ;
:   foaf:age       "208"^^<http://www.w3.org/2001/XMLSchema#int> ;
:   foaf:homepage  <http://uio.no> ;
:   foaf:name      "University of Oslo"
: ] .
: 
 
#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+NAME: inst-org-uio
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle :tangle files/01-basics/15/ins/Organisation.stottr
<<turtle-prefixes>>
ex:Organization("University of Oslo", "208"^^xsd:int, <http://uio.no>) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
ex:Organization[ , , ] :: {
  # add instances here
} .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: tpl-organization-wotypes
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle :tangle files/01-basics/15/tpl/Organisation.stottr
<<turtle-prefixes>>
ex:Organization[ ?name, ?age, ?url] :: {
    ottr:Triple(_:org, rdf:type, foaf:Organization),
    ottr:Triple(_:org, foaf:name, ?name),
    ottr:Triple(_:org, foaf:age, ?age),
    ottr:Triple(_:org, foaf:homepage, ?url)
} .
#+END_SRC



** Base templates

   A /base template/ is a template with no pattern.

   This is an example of a base template:
#+BEGIN_SRC ttl
ex:MyTriple{?s, ?p, ?o} :: BASE .
#+END_SRC
   
   The process of expanding instances terminates until all instances
   are instances of base templates. Any further processing of base
   template instances must be handled by the implementation. In the
   current specification and implementation, ~ottr:Triple~ is the only
   such base template; and instances of ~ottr:Triple~ represent
   (regular) RDF triples.

   It is possible to specify your own base templates, however we do
   not yet support specifying how such instances are handled, so an
   instance of a user defined template will simply be "left as is".

** Exercise: Create a base template

   Exercise: Declare the ~ex:Organization~ template as a /base
   template/, expand and see the results.

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export
<<inst-org-uio>>
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
ex:Organization[ , , ] :: {

} .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+BEGIN_SRC ttl
ex:Organisation[?name, ?age, ?homepage] :: BASE .
#+END_SRC

* Nesting templates

  The pattern of a template can contain any template instances, not
  just instances of ~ottr:Triple~ as we have seen in the examples so
  far. However, cyclic template definitions are not allowed and will
  result in an error.

  The ability to compose templates from existing templates is a
  powerful feature of OTTR templates which allows templates to hide
  the complexity of modelling patterns at different levels of
  abstraction.

** Exercise: Refactoring

   Below is the definition of the template ~ex:Type~. (This templates'
   parameters are /typed/---ignore this for now, we will learn what
   types are in the next section.)

   Change the templates in the previous exercises to use this template
   instead of the ~ottr:Triple~ instances with ~rdf:type~ as argument.
   
   To see what the ~ex:Type~ template expands to, we have provided
   some example instances below.

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
ex:Type(ex:Per, foaf:Person) .
ex:Type(ex:Kari, foaf:Person) .

ex:Type(foaf:Person, rdfs:Class) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+NAME: tpl-type
#+BEGIN_SRC ttl
ex:Type[ottr:IRI ?individual, ottr:IRI ?type] :: {
  ottr:Triple(?individual, rdf:type, ?type)
} .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+BEGIN_SRC ttl
ex:Organization[?name, ?age, ?url] :: {
    ex:Type(_:org, foaf:Organization),
    ottr:Triple(_:org, foaf:name, ?name),
    ottr:Triple(_:org, foaf:age, ?age),
    ottr:Triple(_:org, foaf:homepage, ?url)
} .
#+END_SRC

** Exercise

The templates below are ill-defined; why?

#+ATTR_HTML: :class error
#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/3/ins/cycle.stottr 
<<turtle-prefixes>>
ex:A(ex:uri) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes  :tangle files/01-basics/3/tpl/cycle.stottr
<<turtle-prefixes>>
ex:A[?x] :: { ex:B(?x) } .
ex:B[?x] :: { ex:C(?x) } .
ex:C[?x] :: { ex:A(?x) } .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

The templates are ill-defined because there is a cyclic dependency: 

#+BEGIN_SRC dot :file exercise-cycle.png :noweb yes :exports results
digraph {
A -> B -> C -> A 
}
#+END_SRC

#+RESULTS:
[[file:exercise-cycle.png]]


Lutra will print these errors:

#+CALL: lutra(args="-l files/01-basics/3/tpl/cycle.stottr -L stottr -O stottr -I stottr files/01-basics/3/ins/cycle.stottr")

#+RESULTS:
: 
: [ERROR] Template with IRI http://example.com/ns#A transitively depends on itself.
: 
: [ERROR] Template with IRI http://example.com/ns#C transitively depends on itself.
: 
: [ERROR] Template with IRI http://example.com/ns#B transitively depends on itself.


* Types

  Each template parameter has a /type/. The type specifies the
  permissible type or datatype the corresponding argument may
  have, the argument type must be /compatible/ [[[mottr]]] with the parameter
  type. In essence, a parameter with type ~X~ requires that the type
  of the argument is ~X~ or a subtype of ~X~.

  The permissible types are classes from the RDF, RDFS, OWL and XSD
  vocabularies and specifications, including lists; see rOTTR [[[rottr]]]
  for the full list and hierarchy.

  The default type which is used in case no type is specified, as in
  the previous examples, is the most general one, ~rdfs:Resource~.

  We also check that arguments are consistently typed. This is
  relevant for arguments where the lexical value does not identify its
  type, such as for subtypes of ~ottr:IRI~, e.g., ~owl:Class~ and
  ~owl:ObjectProperty~. An argument can not be used in way that forces
  it to have an illegal or non-existing type, for instance an argument
  cannot have both the type ~owl:ObjectProperty~ and
  ~owl:DatatypeProperty~.


  Types are specified like the following, by setting the type before 
  the parameter variable. Here we extend the ~ex:Person~ template seen earlier
  with types, showing only the signature:

#+BEGIN_SRC ttl
ex:Person[ 
  ottr:IRI ?person, 
  xsd:string ?firstName, 
  xsd:string ?lastName, 
  ottr:IRI ?email ] .
#+END_SRC

** Exercise

   What is the type error?

#+ATTR_HTML: :class error
#+BEGIN_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="mode" value="lint"/>
#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes  :tangle files/01-basics/4/tpl/type-error1.stottr
<<turtle-prefixes>>
ex:A[ ottr:IRI ?x ] :: BASE .

ex:B [ xsd:string ?x ] :: { ex:A(?x) } .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

Lutra's error message explains:

#+CALL: lutra(args="--mode lint -l files/01-basics/4/tpl/type-error1.stottr -L stottr")  :results html

#+RESULTS:
#+BEGIN_EXPORT html

[ERROR] Template with IRI http://example.com/ns#B has incompatible use of term x with intrinsic type http://www.w3.org/2001/XMLSchema#string is used as argument to parameter with type http://ns.ottr.xyz/0.4/IRI in instance http://example.com/ns#A(x)
#+END_EXPORT


** Exercise

   What is the type error?

#+ATTR_HTML: :class error
#+BEGIN_weblutra
#+HTML: <input type="hidden" class="reset-value" data-name="mode" value="lint"/>
#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl  :noweb strip-export :mkdirp yes  :tangle files/01-basics/4/tpl/type-error2.stottr
<<turtle-prefixes>>
ex:A[ ottr:IRI ?x ] :: BASE .

ex:B [ owl:ObjectProperty ?x ] :: { ex:A(?x) } .

ex:C [ owl:AnnotationProperty ?x ] :: { ex:A(?x) } .

ex:D [ ?x ] :: { ex:B(?x), ex:C(?x) } .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

Lutra's error message explains: 

#+CALL: lutra(args="--mode lint -l files/01-basics/4/tpl/type-error2.stottr -L stottr") :results html

#+RESULTS:
#+BEGIN_EXPORT html

[ERROR] Template with IRI http://example.com/ns#D has incompatible use of term x in instances http://example.com/ns#B(x) and http://example.com/ns#C(x), with corresponding parameters typed as http://www.w3.org/2002/07/owl#ObjectProperty and http://www.w3.org/2002/07/owl#AnnotationProperty respectively.
#+END_EXPORT


** Exercise: Specifying types

    Specify reasonable types for the template ~ex:Organization~
    below. Note, that the template is slightly changed from the above
    and now includes the IRI of the organisation. 

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Organization(ex:uio, "University of Oslo", "208"^^xsd:int, <http://uio.no>) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Organization[?org, ?name, ?age, ?url] :: {
    ex:Type(?org, foaf:Organization),
    ottr:Triple(?org, foaf:name, ?name),
    ottr:Triple(?org, foaf:age, ?age),
    ottr:Triple(?org, foaf:homepage, ?url)
} .

<<tpl-type>>
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: tpl-organization
#+BEGIN_SRC ttl
ex:Organization[ottr:IRI ?org, xsd:string ?name, xsd:int ?age, ottr:IRI ?url] :: {
    ex:Type(?org, foaf:Organization),
    ottr:Triple(?org, foaf:name, ?name),
    ottr:Triple(?org, foaf:age, ?age),
    ottr:Triple(?org, foaf:homepage, ?url)
} .
#+END_SRC


*** QA                                                             :noexport:

    Checking that the templates are ok:

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/2/tpl/Type.stottr
<<turtle-prefixes>>
<<tpl-type>>
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/2/tpl/Organization.stottr
<<turtle-prefixes>>
<<tpl-organization>>
#+END_SRC

#+CALL: lutra(args="--mode lint -l files/01-basics/2/tpl -L stottr")

#+RESULTS:
: No errors found.


* NonBlank 

  A parameter can be specified as /nonblank/, which means it will not
  accept a blank node as argument.

  A parameter is set to be nonblank by writing ~!~ before the
  parameter type, e.g., the ~ottr:Triple~, which according to the RDF
  specification should not allow blank nodes as predicates, can be
  written as:
#+BEGIN_SRC ttl
ottr:Triple [ ottr:IRI ?subject, ! ottr:IRI ?predicate, rdfs:Resource ?object ] :: BASE .
#+END_SRC
  
** Exercise

   The following template is ill-defined; why? Can you fix it?

#+ATTR_HTML: :class error
#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/5/ins/relative.stottr 
<<turtle-prefixes>>
ex:Relative(ex:Bart, ex:hasFather, ex:Homer) .
ex:Relative(ex:Bart, ex:hasMother, ex:Marge) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/5/tpl/relative.stottr 
<<turtle-prefixes>>
ex:Relative[ ottr:IRI ?person, ottr:IRI ?relation, ottr:IRI ?other ] :: {
  ottr:Triple(?person, ?relation, ?other)
} .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

Lutra explains:

#+CALL: lutra(args="-l files/01-basics/5/tpl/relative.stottr -L stottr -I stottr files/01-basics/5/ins/relative.stottr") :results html

#+RESULTS:
#+BEGIN_EXPORT html

[ERROR] Parameter with name relation is not marked as non-blank, but is used as argument to non-blank parameter index 2 in instance of template http://ns.ottr.xyz/0.4/Triple in template http://example.com/ns#Relative
#+END_EXPORT

* Optionals and None
  
  A parameter can be specified as /optional/. This determines how the
  parameter treats arguments which are equal to the specific IRI
  ~ottr:none~, which in stOTTR can be written as just ~none~. ~none~
  is a term that represents a missing or no value.

  An instance with ~none~ as an argument to a non-optional parameter
  will be removed in the expansion, while if the parameter is
  optional, then the instance is not removed. Essentially, optional
  parameters allow ~none~ to be passed on in the expansion.

  Note that all the parameters of the ~ottr:Triple~ template are
  non-optional. If want wants to produce triples with ~none~, one can
  use the base template ~ottr:NullableTriple~.

  A parameter is specified as optional by adding ~?~ before its type. 

  ~ottr:NullableTriple~ can be specified as
#+BEGIN_SRC ttl
ottr:NullableTriple[? ottr:IRI ?subject, !? ottr:IRI ?predicate, ? rdfs:Resource ?object ] :: BASE .
#+END_SRC

** Exercise: Triple vs. NullableTriple

   Observe the difference of expanding ~ottr:Triple~ and
   ~ottr:NullableTriple~ by changing the pattern of ~ex:TripleWrapper~
   from using ~ottr:Triple~ to using ~ottr:NullableTriple~.

   Look closely at the signature of ~ex:TripleWrapper~ and make sure
   you understand it.

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl  :noweb strip-export :mkdirp yes :tangle files/01-basics/6/ins/nullable.stottr 
<<turtle-prefixes>>
ex:TripleWrapper(ex:s1, ex:p1, ex:o1) .
ex:TripleWrapper(none, ex:p2, ex:o2) .
ex:TripleWrapper(ex:s3, none, ex:o3) .
ex:TripleWrapper(ex:s4, ex:p4, none) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/6/tpl/nullable.stottr 
<<turtle-prefixes>>
ex:TripleWrapper[ ? ottr:IRI ?s, !? ottr:IRI ?p, ??o ] :: { 
  ottr:Triple(?s, ?p, ?o ) 
  # ottr:NullableTriple(?s, ?p, ?o ) 
} . 
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

    Here is an explanation of the parameters of the
    ~ex:TripleWrapper~:

#+BEGIN_SRC ttl
ex:TripleWrapper[ 
  ? ottr:IRI ?s,   # ? = optional, ottr:IRI = type, ?s = parameter
  !? ottr:IRI ?p,  # ? = optional, ! = nonBlank, ottr:IRI = type, ?p = parameter
  ??o              # ? = optional, [no type, means rdfs:Resource], ?o = parameter
] .
#+END_SRC

If the ~ottr:TripleWrapper~ does not contain ~ottr:NullableTriple~ in
the pattern, the resulting graph will contain no ~none~ values (which
is shorthand for the IRI ~ottr:none~). This is because none of the
parameters of the ~ottr:Triple~ template are optional. If using
~ottr:NullableTriple~, ~ottr:none~ resources will appear in the
resulting expansion, since all of ~ottr:NullableTriple~'s parameters
are optional.

*** QA                                                             :noexport:

#+CALL: lutra(args="-l files/01-basics/6/tpl/nullable.stottr -L stottr -I stottr files/01-basics/6/ins/nullable.stottr")

#+RESULTS:
#+begin_example
@prefix ex:    <http://example.com/ns#> .
@prefix ottr:  <http://ns.ottr.xyz/0.4/> .

ex:s3   ottr:none  ex:o3 .

ottr:none  ex:p2  ex:o2 .

ex:s1   ex:p1   ex:o1 .

ex:s4   ex:p4   ottr:none .

#+end_example

** Exercise: Optionals

    Change the ~ex:Person~ template below so the first name is
    optional, and the instances below expand to the following:

#+CALL: lutra(args="-L stottr -l files/01-basics/7/tpl/Person.stottr -I stottr files/01-basics/7/ins/Person.stottr")

#+RESULTS:
#+begin_example
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .

<http://example.com/ns#mary>
        a               foaf:Person ;
        foaf:firstName  "Mary" ;
        foaf:lastName   "Stone" ;
        foaf:mbox       <mailto:mstone@uio.no> .

<http://example.com/ns#smith>
        a              foaf:Person ;
        foaf:lastName  "Smith" ;
        foaf:mbox      <mailto:smith@mail.no> .

#+end_example

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+NAME: person-ins-7
#+BEGIN_SRC ttl 
ex:Person(ex:mary, "Mary", "Stone", <mailto:mstone@mail.com>) .
ex:Person(ex:smith, none, "Smith", <mailto:smith@mail.com>) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Person[ ottr:IRI ?person, xsd:string ?firstName, xsd:string ?lastName, ottr:IRI ?email ] :: {
  ex:Type (?person, foaf:Person ),
  ottr:Triple (?person, foaf:firstName, ?firstName ),
  ottr:Triple (?person, foaf:lastName, ?lastName ),
  ottr:Triple (?person, foaf:mbox, ?email )
} .

<<tpl-type>>
#+END_SRC
#+END_library
#+END_weblutra


*** Solution

#+NAME: tpl-person-w-type
#+BEGIN_SRC ttl :noweb yes
ex:Person[ ottr:IRI ?person, ? xsd:string ?firstName, xsd:string ?lastName, ottr:IRI ?email ] :: {
  ex:Type (?person, foaf:Person ),
  ottr:Triple (?person, foaf:firstName, ?firstName ),
  ottr:Triple (?person, foaf:lastName, ?lastName ),
  ottr:Triple (?person, foaf:mbox, ?email )
} .

<<tpl-type>>
#+END_SRC

#+COMMENT: tangle person and type to file to avoid including prefixes above

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/7/ins/Person.stottr
<<turtle-prefixes>>
<<person-ins-7>>
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/7/tpl/Person.stottr
<<turtle-prefixes>>
<<tpl-person-w-type>>
#+END_SRC


* Default values

  Parameters can specify a /default value/. The default value is used
  if the argument is ~none~. The default value can be any term. If the
  default value is a blank node, a fresh blank node will be used for
  each instance.

  A default value is specified appending the value to the parameter
  variable separated by ~=~, i.e., ~?variable=default~.

** Exercise

   The template 
 : ax:SubObjectSomeValuesFrom[owl:Class ?class, owl:ObjectProperty ?property, owl:Class ?qualifier ] . 
 can be used to create OWL axioms of the form $C \sqsubseteq \exists P . D$

   How would you need to change the signature so that the instance
: ax:SubObjectSomeValuesFrom(ex:A, ex:Q, none) .
  would produce
$A \sqsubseteq \exists Q . \top$

*** Solution

Change the signature to

 : ax:SubObjectSomeValuesFrom[owl:Class ?class, owl:ObjectProperty ?property, owl:Class ?qualifier = owl:Thing ] . 

** Exercise: Setting concrete default values

    Change the template ~ex:Organization~ to include an extra argument
    ~?loc~ which states that the organisation is ~dbp:locatedIn ?loc~
    and which defaults to ~ex:norway~, so that the following instances
    expand to:

#+CALL: lutra(args="-L stottr -l files/01-basics/8/tpl/organisation.stottr -I stottr files/01-basics/8/ins/organisation.stottr")

#+RESULTS:
#+begin_example
@prefix dbp:   <http://dbpedia.org/ontology/> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .

<http://example.com/ns#uio>
        a              foaf:Organization ;
        dbp:locatedIn  <http://example.com/ns#norway> ;
        foaf:age       "208"^^<http://www.w3.org/2001/XMLSchema#int> ;
        foaf:homepage  <http://uio.no> ;
        foaf:name      "University of Oslo" .

<http://example.com/ns#google>
        a              foaf:Organization ;
        dbp:locatedIn  <http://example.com/ns#usa> ;
        foaf:age       "21"^^<http://www.w3.org/2001/XMLSchema#int> ;
        foaf:homepage  <http://google.com> ;
        foaf:name      "Google AS" .

#+end_example

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/8/ins/organisation.stottr
<<turtle-prefixes>>
ex:Organization(ex:uio, "University of Oslo", "208"^^xsd:int, <http://uio.no>, none) .
ex:Organization(ex:google, "Google AS", "21"^^xsd:int, <http://google.com>, ex:usa) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
<<tpl-organization>>

<<tpl-type>>
#+END_SRC
#+END_library
#+END_weblutra


*** Solution

#+NAME: tpl-organization-norway
#+BEGIN_SRC ttl 
ex:Organization[ottr:IRI ?org, xsd:string ?name, xsd:int ?age, ottr:IRI ?url, ottr:IRI ?loc=ex:norway] :: {
    ex:Type(?org, foaf:Organization),
    ottr:Triple(?org, foaf:name, ?name),
    ottr:Triple(?org, foaf:age, ?age),
    ottr:Triple(?org, dbp:locatedIn, ?loc),
    ottr:Triple(?org, foaf:homepage, ?url)
} .
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb strip-export :mkdirp yes :tangle files/01-basics/8/tpl/organisation.stottr
<<turtle-prefixes>>
<<tpl-organization-norway>>
<<tpl-type>>
#+END_SRC

** Exercise: Setting blank node default values

    Change the template ~ex:Person~ so that it generates
    a fresh blank node if no IRI is provided for the person.
    The instances below should expand to:

#+CALL: lutra(args="-L stottr -l files/01-basics/9/tpl/person.stottr -I stottr files/01-basics/9/ins/person.stottr")

#+RESULTS:
#+begin_example
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .

[ a               foaf:Person ;
  foaf:firstName  "Ann" ;
  foaf:lastName   "Jones" ;
  foaf:mbox       <mailto:ann@mail.com>
] .

<http://example.com/ns#cindy>
        a               foaf:Person ;
        foaf:firstName  "Cindy" ;
        foaf:lastName   "Stevens" ;
        foaf:mbox       <mailto:cindy@mail.com> .

[ a               foaf:Person ;
  foaf:firstName  "Bill" ;
  foaf:lastName   "Bright" ;
  foaf:mbox       <mailto:bill@mail.com>
] .

#+end_example

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/9/ins/person.stottr
<<turtle-prefixes>>
ex:Person(none, "Ann", "Jones", <mailto:ann@mail.com>) .
ex:Person(none, "Bill", "Bright", <mailto:bill@mail.com>) .
ex:Person(ex:cindy, "Cindy", "Stevens", <mailto:cindy@mail.com>) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Person[ ottr:IRI ?person, ? xsd:string ?firstName, xsd:string ?lastName, ottr:IRI ?email ] :: {
  ex:Type (?person, foaf:Person ),
  ottr:Triple (?person, foaf:firstName, ?firstName ),
  ottr:Triple (?person, foaf:lastName, ?lastName ),
  ottr:Triple (?person, foaf:mbox, ?email )
} .

<<tpl-type>>
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: tpl-person-blanknode
#+BEGIN_SRC ttl
ex:Person[ ottr:IRI ?person=_:person, xsd:string ?firstName, xsd:string ?lastName, ottr:IRI ?email ] :: {
  ex:Type (?person, foaf:Person ),
  ottr:Triple (?person, foaf:firstName, ?firstName ),
  ottr:Triple (?person, foaf:lastName, ?lastName ),
  ottr:Triple (?person, foaf:mbox, ?email )
} .
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/9/tpl/person.stottr
<<turtle-prefixes>>
<<tpl-person-blanknode>>
<<tpl-type>>
#+END_SRC


** Exercise: Specifying relationship between organisation and persons

    Make a new template ~ex:Member~ that takes three arguments:
    1. ~?org~ the IRI of an organisation,
    2. ~?person~ the IRI of a person,
    3. ~?relation~ the IRI of the relationship between the
       organisation and the person (e.g. ~foaf:member~, ~ex:employee~,
       ~ex:associate~). It should default to ~foaf:member~.

    Add types and other necessary flags to make the template
    correct. The pattern should contain a single triple instance
    stating that the ~?org~ is ~?relation~ related to ~?person~, so
    that the following instances expands to:

#+CALL: lutra(args="-L stottr -l files/01-basics/10/tpl/member.stottr -I stottr files/01-basics/10/ins/member.stottr")

#+RESULTS:
: @prefix ex:    <http://example.com/ns#> .
: @prefix foaf:  <http://xmlns.com/foaf/0.1/> .
: 
: ex:busAZ  ex:employee  ex:bob .
: 
: ex:united_nations  foaf:member  ex:norway .
: 

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/10/ins/member.stottr
<<turtle-prefixes>>
ex:Member(ex:busAZ, ex:bob, ex:employee) .
ex:Member(ex:united_nations, ex:norway, none) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Member[ ?org, ?person, ?relation ] :: {

} .
#+END_SRC
#+END_library
#+END_weblutra


*** Solution

#+NAME: tpl-member
#+BEGIN_SRC ttl
ex:Member[ottr:IRI ?org, ottr:IRI ?person, ! ottr:IRI ?relation=foaf:member] :: {
    ottr:Triple(?org, ?relation, ?person)
} .
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb strip-export :mkdirp yes :tangle files/01-basics/10/tpl/member.stottr
<<turtle-prefixes>>
<<tpl-member>>
#+END_SRC

* Expansion modes

  Instances in a template pattern can be marked with an /expansion
  mode/. Expansion modes are used to create multiple instances from
  arguments which are lists. There are different expansion modes which
  behave differently when multiple list arguments are in play. The
  current list of expansion modes are ~cross~, ~zipMin~ and ~zipMax~.

  An pattern instance is marked by adding the expansion mode like this:
  ~cross | [Instance]~

  The list argument to which the expansion mode is applied must be
  selected. This is done by adding ~++~ to the argument like this:
  ~++?argument~

** Exercise: Getting acquainted with expansion modes

   The template ~ex:Types~ below can be used to express that an IRI
   has multiple classes. This is done by marking the instance
   ~ex:Type~ in the pattern of ~ex:Types~ with an expansion mode. The
   result of expanding the instance below is the following:
   
#+CALL: lutra(args="-L stottr -l files/01-basics/14/tpl/expmode.stottr -I stottr files/01-basics/14/ins/expmode.stottr")

#+RESULTS:
: @prefix ex:    <http://example.com/ns#> .
: @prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
: 
: ex:ann  a       ex:Employee , ex:Mother , ex:Person .
: 

Essentially, the expansion mode specifies that an instance of
~ex:Type~ is created for each element in the list of the second
argument of ~ex:Types~. What really happens is that an instance for
each element in the cross product of all the arguments to ~ex:Type~ is
created, temporarily treating all arguments as lists:
\(\langle ann \rangle \times \langle Person, Employee \rangle 
= \{ \langle ann, Person \rangle ,\langle ann, Employee \rangle \}\)



#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/14/ins/expmode.stottr
<<turtle-prefixes>>
ex:Types(ex:ann, (ex:Person, ex:Employee)) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+NAME: expmode-tpl-14
#+BEGIN_SRC ttl :noweb yes
ex:Types[ ottr:IRI ?inst, List<ottr:IRI> ?class ] :: {
  cross | ex:Type(?inst, ++?class)
} .

<<tpl-type>>
#+END_SRC
#+END_library
#+END_weblutra

#+BEGIN_SRC ttl :exports none :noweb yes :mkdirp yes :tangle files/01-basics/14/tpl/expmode.stottr
<<turtle-prefixes>>
<<expmode-tpl-14>>
#+END_SRC


Exercises: 
 1. Change the signature of ~ex:Types~ so that the type of the first
    parameter is also ~List<ottr:IRI>~ and mark the argument ~?inst~ in
    the pattern with ~++~. Now change the instance in the input box to
    : ex:Types((ex:ann, ex:bob, ex:cindy, ex:david), (ex:Person, ex:Employee))
    and see what this expands to.
 2. Keep the setup as in 1., but now change the expansion mode to
    ~zipMin~ and see what happens with the expansion results.
 3. Now change the expansion mode to ~zipMax~ and see what happens.

*** Solution

    1. ~cross~: \langle A, B, C \rangle \times \langle X, Y \rangle = 
       {
        \langle A, X \rangle ,
        \langle B, X \rangle ,
        \langle C, X \rangle ,
        \langle A, Y \rangle ,
        \langle B, Y \rangle ,
        \langle C, Y \rangle }

    2. ~zipMin~ zips the lists, but only the size of the shortest list: 
       zipMin(\langle A, B, C \rangle,   \langle X, Y \rangle)= 
       {
        \langle A, X \rangle ,
        \langle B, Y \rangle }.

    3. ~zipMax~ zips the lists, and appends shorter lists with ~none~ to match the size of the longest list: 
       zipMax(\langle A, B, C \rangle,   \langle X, Y \rangle)= 
       {
        \langle A, X \rangle ,
        \langle B, Y \rangle 
        \langle C, none \rangle }.
  
** Exercise: Setting expansion modes

    Make a new template ~ex:Members~ that takes an organisation, a
    list of individuals (given as IRIs), and a relation as argument
    and produces a ~ex:Member~ instance between the organization and
    each of the persons in the list. The instances below should expand
    to:

#+CALL: lutra(args="-L stottr -l files/01-basics/11/tpl/members.stottr -I stottr files/01-basics/11/ins/members.stottr")

#+RESULTS:
: @prefix ex:    <http://example.com/ns#> .
: @prefix foaf:  <http://xmlns.com/foaf/0.1/> .
: 
: ex:united_nations  foaf:member  ex:norway , ex:france , ex:usa , ex:germany .
: 
: ex:fast  ex:employee  ex:bob , ex:ann , ex:carl .
: 

    Note the use of optional flag in the signature so that a ~none~
    value gets passed on to the ~ex:Member~ template, which then uses
    the default value ~foaf:member~.

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/11/ins/members.stottr
<<turtle-prefixes>>
ex:Members(ex:fast, (ex:ann, ex:bob, ex:carl), ex:employee) .
ex:Members(ex:united_nations, (ex:usa, ex:germany, ex:france, ex:norway), none) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:Members[ ottr:IRI ?org, List<ottr:IRI> ?members, !? ottr:IRI ?relation] :: {

} .

<<tpl-member>>
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: tpl-members
#+BEGIN_SRC ttl
ex:Members[ ottr:IRI ?org, List<ottr:IRI> ?members, !? ottr:IRI ?relation ] :: {
    cross | ex:Member(?org, ++?members, ?relation)
} .
#+END_SRC


#+BEGIN_SRC ttl :exports none :noweb strip-export :mkdirp yes :tangle files/01-basics/11/tpl/members.stottr
<<turtle-prefixes>>
<<tpl-members>>
<<tpl-member>>
#+END_SRC

** Exercise (*): Exploiting expansion modes

    Make a template ~ex:Friends~ with the signature below, that from
    the given the instances produces the following, i.e., everybody
    knows everybody.

#+CALL: lutra(args="-L stottr -l files/01-basics/12/tpl/friends.stottr -I stottr files/01-basics/12/ins/friends.stottr")

#+RESULTS:
#+begin_example
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .

<http://example.com/ns#daniel>
        foaf:knows  <http://example.com/ns#daniel> , <http://example.com/ns#martin> , <http://example.com/ns#leif> .

<http://example.com/ns#leif>
        foaf:knows  <http://example.com/ns#daniel> , <http://example.com/ns#martin> , <http://example.com/ns#leif> .

<http://example.com/ns#martin>
        foaf:knows  <http://example.com/ns#leif> , <http://example.com/ns#martin> , <http://example.com/ns#daniel> .

#+end_example

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/12/ins/friends.stottr
<<turtle-prefixes>>
ex:Friends((ex:ann, ex:bob, ex:carl)) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl
ex:Friends[ List<ottr:IRI> ?friends] :: {

} .
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: tpl-friends
#+BEGIN_SRC ttl
ex:Friends[ List<ottr:IRI> ?friends] :: {
  cross | ottr:Triple(++?friends, foaf:knows, ++?friends)
} .
#+END_SRC

#+BEGIN_SRC ttl :exports none :noweb strip-export :mkdirp yes :tangle files/01-basics/12/tpl/friends.stottr
<<turtle-prefixes>>
<<tpl-friends>>
#+END_SRC


** Exercise: NamedPizza

   The NamedPizza template, published at
   http://tpl.ottr.xyz/pizza/0.1/NamedPizza, uses lists both with and
   without expansion modes. The list of toppings is used to create a
   union of classes using the
   http://tpl.ottr.xyz/owl/restriction/0.1/ObjectUnionOf template,
   *and* to create a instance of
   http://tpl.ottr.xyz/owl/axiom/0.1/SubObjectSomeValuesFrom for each
   topping in the list.

   Try and make new pizzas and see the results.

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/15/ins/namedpizza.stottr
<<turtle-prefixes>>
@prefix o-pizza: <http://tpl.ottr.xyz/pizza/0.1/> .

o-pizza:NamedPizza(ex:Margerita, ex:Italy, (ex:Tomato, ex:Mozzarella)) .

o-pizza:NamedPizza(ex:QuattroFormaggi, ex:Italy, (ex:Tomato, ex:Mozzarella, ex:Gorgonzola, ex:Parmesan, ex:Stracchino)) .

o-pizza:NamedPizza(ex:Grandiosa, ex:Norway, (ex:Tomato, ex:Cheese, ex:BellPepper, ex:Ham)) .

o-pizza:NamedPizza(ex:PepperoniPizza, ottr:none, (ex:Tomato, ex:Cheese, ex:Pepperoni)) .
#+END_SRC
#+END_input
#+END_weblutra

** Exercise (**): Using multiple expansion modes

    Make a template ~ex:OrganizationMembers~ with the given signature,
    that given the instance below expands to the following:

#+CALL: lutra(args="-L stottr -l files/01-basics/13/tpl/orgmembers.stottr -I stottr files/01-basics/13/ins/orgmembers.stottr")



#+RESULTS:
#+begin_example
@prefix dbp:   <http://dbpedia.org/ontology/> .
@prefix ex:    <http://example.com/ns#> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .

ex:uio  a              foaf:Organization ;
        dbp:locatedIn  ex:norway ;
        ex:employee    ex:leif , ex:daniel , ex:martin ;
        foaf:age       "208"^^<http://www.w3.org/2001/XMLSchema#int> ;
        foaf:homepage  <http://uio.no> ;
        foaf:name      "University of Oslo" .

ex:daniel  a            foaf:Person ;
        foaf:firstName  "Daniel" ;
        foaf:knows      ex:leif , ex:martin , ex:daniel ;
        foaf:lastName   "Lupp" ;
        foaf:mbox       <mailto:danielup@ifi.uio.no> .

ex:leif  a              foaf:Person ;
        foaf:firstName  "Leif Harald" ;
        foaf:knows      ex:leif , ex:daniel , ex:martin ;
        foaf:lastName   "Karlsen" ;
        foaf:mbox       <mailto:leifhka@ifi.uio.no> .

ex:martin  a            foaf:Person ;
        foaf:firstName  "Martin" ;
        foaf:knows      ex:martin , ex:leif , ex:daniel ;
        foaf:lastName   "Skj√¶veland" ;
        foaf:mbox       <mailto:martige@ifi.uio.no> .

#+end_example

#+BEGIN_weblutra
#+BEGIN_input
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/13/ins/orgmembers.stottr
<<turtle-prefixes>>
ex:OrganizationMembers(
  ex:uio, "University of Oslo", "208"^^xsd:int, <http://uio.no>, none, ex:employee,
  (ex:leif,                     ex:daniel,                    ex:martin),
  ("Leif Harald",               "Daniel",                     "Martin"),
  ("Karlsen",                   "Lupp",                       "Skj√¶veland"),
  (<mailto:leifhka@ifi.uio.no>, <mailto:danielup@ifi.uio.no>, <mailto:martige@ifi.uio.no>)
) .
#+END_SRC
#+END_input

#+BEGIN_library
#+ATTR_HTML: :textarea t
#+BEGIN_SRC ttl :noweb yes
ex:OrganizationMembers[
    ottr:IRI ?org, xsd:string ?name, xsd:int ?age, ottr:IRI ?url,
    ? ottr:IRI ?loc, !? ottr:IRI ?relation,
    List<ottr:IRI>   ?members,
    List<xsd:string> ?memberFirstNames,
    List<xsd:string> ?memberLastNames,
    List<ottr:IRI>   ?memberMboxes
] :: {


} .

<<orgmembers-deps>>
#+END_SRC
#+END_library
#+END_weblutra

*** Solution

#+NAME: orgmembers-deps
#+BEGIN_SRC ttl :exports none :noweb yes
#### no need to change the templates below this line

<<tpl-type>>

<<tpl-person-blanknode>>

<<tpl-organization-norway>>

<<tpl-members>>

<<tpl-member>>

<<tpl-friends>>
#+END_SRC


#+BEGIN_SRC ttl :noweb strip-export :mkdirp yes :tangle files/01-basics/13/tpl/orgmembers.stottr
<<turtle-prefixes>>
ex:OrganizationMembers[
    ottr:IRI ?org, xsd:string ?name, xsd:int ?age, ottr:IRI ?url,
    ? ottr:IRI ?loc, !? ottr:IRI ?relation,
    List<ottr:IRI>   ?members,
    List<xsd:string> ?memberFirstNames,
    List<xsd:string> ?memberLastNames,
    List<ottr:IRI>   ?memberMboxes]
:: {
  ex:Organization(?org, ?name, ?age, ?url, ?loc),
  zipMin | ex:Person(++?members, ++?memberFirstNames, ++?memberLastNames, ++?memberMboxes),
  ex:Members(?org, ?members, ?relation),
  ex:Friends(?members) 
} .

<<orgmembers-deps>>
#+END_SRC

* References

  1. <<mottr>> mOTTR: Concepts and Abstract Model for Reasonable Ontology
     Templates http://spec.ottr.xyz/mOTTR/0.1/
  2. <<rottr>> rOTTR: Adapting Reasonable Ontology Templates to RDF
     http://spec.ottr.xyz/rOTTR/0.2/
  3. <<stottr>> stOTTR: Terse Syntax for Reasonable Ontology Templates
     http://spec.ottr.xyz/stOTTR/0.1/
  4. <<wottr>> wOTTR: Web Reasonable Ontology Templates
     http://spec.ottr.xyz/wOTTR/0.4/

* Appendix

#+INCLUDE: "./inc/appendix.org"



